% Appendix Template

\chapter{Image Analysis Python Source Code} % Main appendix title

\label{Appendix_ImageAnalysisCode} % Change X to a consecutive letter; for referencing this appendix elsewhere, use \ref{AppendixX}

\begin{lstlisting}[language=Python, caption=Image Analysis Source Code, label=lis:imageAnalysisSourceCode]
# import the necessary packages
import numpy as np
import argparse
import imutils
import cv2 # pip install opencv-python
import matplotlib.pyplot as plt
# import torch
# import torchvision.transforms as T

from IPython.display import display, Image
from easydict import EasyDict
from scipy.spatial import distance as dist
from imutils import perspective
from imutils import contours

def midpoint(ptA, ptB):
    return ((ptA[0] + ptB[0]) * 0.5, (ptA[1] + ptB[1]) * 0.5)

def order_points(pts):
    # sort the points based on their x-coordinates
    xSorted = pts[np.argsort(pts[:, 0]), :]
    
    # grab the left-most and right-most points from the sorted
    # x-roodinate points
    leftMost = xSorted[:2, :]
    rightMost = xSorted[2:, :]
    
    # now, sort the left-most coordinates according to their
    # y-coordinates so we can grab the top-left and bottom-left
    # points, respectively
    leftMost = leftMost[np.argsort(leftMost[:, 1]), :]
    (tl, bl) = leftMost
    
    # now that we have the top-left coordinate, use it as an
    # anchor to calculate the Euclidean distance between the
    # top-left and right-most points; by the Pythagorean
    # theorem, the point with the largest distance will be
    # our bottom-right point
    D = dist.cdist(tl[np.newaxis], rightMost, "euclidean")[0]
    (br, tr) = rightMost[np.argsort(D)[::-1], :]
    
    # return the coordinates in top-left, top-right,
    # bottom-right, and bottom-left order
    return np.array([tl, tr, br, bl], dtype="float32")
    
def measureImg(
    orimgname_, imgname_, refIsXval, refImg, refVal, edgeType, 
    minObjArea, invertPimg, Threshold=128, denoise=0):
    
    #TUNE fineTuning TO MATCH THE REFERENCE OBJECT

    ### IMAGE PRE-PROCESSING
    # load the image
    orimg = cv2.imread(orimgname_)
    img = cv2.imread(imgname_)
    
    # Image Denoising
    dst = cv2.fastNlMeansDenoisingColored(
        src=img,
        dst=None,
        h=denoise,
        hColor=denoise,
        templateWindowSize=7,
        searchWindowSize=21)

    # Convert to grayscale
    grey = cv2.cvtColor(dst, cv2.COLOR_BGR2GRAY)
    
    cv2.imwrite('./img_grey.png', grey)

    # define a threshold, 128 is the middle of black and white
    # in grey scale
    thresh = Threshold #256/2

    # assign blue channel to zeros
    binary = cv2.threshold(grey, thresh, 256, cv2.THRESH_BINARY)[1]

    cv2.imwrite('./img_binary.png', binary)
    
#     # Inverting the colors
#     invert = abs(255 - binary)
    
    ### IMAGE PROCESSING
    # perform edge detection, then perform a dilation + erosion
    # to close gaps in between object edges
    if invertPimg:
        edged = cv2.Canny(binary, Threshold, Threshold)
    else:
        edged = cv2.Canny(grey, Threshold, Threshold)
        
    cv2.imwrite('./img_edged.png', edged)

    dilated = cv2.dilate(edged, None, iterations=1)
    eroded = cv2.erode(dilated, None, iterations=1)
    
    cv2.imwrite('./img_dilated.png', dilated)
    cv2.imwrite('./img_eroded.png', eroded)

    if edgeType == "dilated":
        Pimg = dilated
    elif edgeType == "eroded":
        Pimg = eroded
    else:
        Pimg = edged
    
    # Show and save image
    print()
    print('Image to Process:')
    imgname='./img_out.png'
    cv2.imwrite(imgname,Pimg)
    display(Image(filename=imgname))
    
    ### GET IMAGE MEASUREMENTS
    # find contours in the edge map
    cnts = cv2.findContours(
        Pimg.copy(),
        cv2.RETR_EXTERNAL,
        cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)

    # sort the contours from left-to-right and initialize the
    # 'pixels per metric' calibration variable
    (cnts, _) = contours.sort_contours(cnts)
    
    # if the pixels per metric has not been initialized, then
    # compute it as the ratio of pixels to supplied metric
    # (in this case, inches) to match the reference object
    pixelsPerMetric = None
    i = 0
    for c in reversed(cnts):
        if cv2.contourArea(c) < minObjArea:
            continue
            
        if i == refImg and pixelsPerMetric is None:
            box = cv2.minAreaRect(c)
            box = cv2.cv.BoxPoints(box)
                if imutils.is_cv2()
                else cv2.boxPoints(box)
            box = np.array(box, dtype="int")
            box = perspective.order_points(box)
            (tl, tr, br, bl) = box
            (tltrX, tltrY) = midpoint(tl, tr)
            (blbrX, blbrY) = midpoint(bl, br)
            (tlblX, tlblY) = midpoint(tl, bl)
            (trbrX, trbrY) = midpoint(tr, br)
            dA = dist.euclidean((tltrX, tltrY), (blbrX, blbrY))
            dB = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))
            if refIsXval:
                pixelsPerMetric = dB*(25400000/refVal)
            else:
                pixelsPerMetric = dA*(25400000/refVal)
        i += 1
        #print(pixelsPerMetric)

    # loop over the contours individually
    i = 0
    for c in reversed(cnts):
        # if the contour is not sufficiently large, ignore it
        if cv2.contourArea(c) < minObjArea:
            continue

        # compute the rotated bounding box of the contour
        orig = orimg.copy()
        box = cv2.minAreaRect(c)        
        box = cv2.cv.BoxPoints(box)
            if imutils.is_cv2()
            else cv2.boxPoints(box)
        box = np.array(box, dtype="int")

        # order the points in the contour such that they appear
        # in top-left, top-right, bottom-right, and bottom-left
        # order, then draw the outline of the rotated bounding
        # box
        box = perspective.order_points(box)
        cv2.drawContours(
            orig,
            [box.astype("int")],
            -1,
            (0, 255, 0),
            1)

        # loop over the original points and draw them
        for (x, y) in box:
            cv2.circle(orig, (int(x), int(y)), 2, (0, 0, 255), -1)

        # unpack the ordered bounding box, then compute the
        # midpoint between the top-left and top-right 
        # coordinates, followed by the midpoint between
        # bottom-left and bottom-right coordinates
        (tl, tr, br, bl) = box
        (tltrX, tltrY) = midpoint(tl, tr)
        (blbrX, blbrY) = midpoint(bl, br)

        # compute the midpoint between the top-left and
        # top-right points, followed by the midpoint between the 
        # top-righ and bottom-right
        (tlblX, tlblY) = midpoint(tl, bl)
        (trbrX, trbrY) = midpoint(tr, br)

        # draw the midpoints on the image
        cv2.circle(orig, (int(tltrX), int(tltrY)),
            2, (255, 0, 0), -1)
        cv2.circle(orig, (int(blbrX), int(blbrY)),
            2, (255, 0, 0), -1)
        cv2.circle(orig, (int(tlblX), int(tlblY)),
            2, (255, 0, 0), -1)
        cv2.circle(orig, (int(trbrX), int(trbrY)),
            2, (255, 0, 0), -1)

        # draw lines between the midpoints
        cv2.line(
            orig,
            (int(tltrX), int(tltrY)),
            (int(blbrX), int(blbrY)),
            (255, 0, 255), 1)
        cv2.line(
            orig,
            (int(tlblX), int(tlblY)),
            (int(trbrX), int(trbrY)),
            (255, 0, 255), 1)

        # compute the Euclidean distance between the midpoints
        dA = dist.euclidean((tltrX, tltrY), (blbrX, blbrY))
        dB = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))
            
        # compute the size of the object
        dimA = dA / pixelsPerMetric
        dimB = dB / pixelsPerMetric

        # convert inches to nm
        dimA = dimA*25400000
        dimB = dimB*25400000
        
        # draw the object sizes on the image
        txtcolor=(255, 171, 0)
        cv2.putText(orig, "{:.2f}nm".format(dimB),
                    (int(tltrX - 15), int(tltrY - 10)), 
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.6, txtcolor, 2, 5)
        cv2.putText(orig, "{:.2f}nm".format(dimA),
                    (int(trbrX + 10), int(trbrY)), 
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.6, txtcolor, 2)

        # Show and save output image
        print()
        print('Measurements in progress ... ' + str(i))
        print('dimX=' + str(round(dimB,2)) + 'nm;  dimY=' + 
            str(round(dimA,2)) + 'nm;')
        imgname='./img_out.png'
        cv2.imwrite(imgname,orig)
        display(Image(filename=imgname))
        i += 1
        
help(measureImg);
display(Image(filename='./img/UScoinRef.png'));
measureImg(
    './img/example_01.png',
    './img/example_01.png',
    True, 5, 24260000,
    'eroded',
    100,
    False,
    Threshold=150,
    denoise=15);
\end{lstlisting}